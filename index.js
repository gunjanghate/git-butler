// import { Command } from 'commander';
// import simpleGit from 'simple-git';
// import dotenv from 'dotenv';
// import chalk from 'chalk';
// import ora from 'ora';
// import { GoogleGenerativeAI } from "@google/generative-ai";

// dotenv.config();
// const git = simpleGit();

// // Warn if no Gemini key
// if (!process.env.GEMINI_API_KEY) {
//   console.warn(chalk.yellow('‚ö† GEMINI_API_KEY not found. AI commit messages will be disabled.'));
// }

// // CLI args
// const program = new Command();
// program
//   .argument('<desc>', 'Short description of the change')
//   .option('--type <type>', 'Commit type', 'feat')
//   .option('--scope <scope>', 'Commit scope', '')
//   .option('--no-ai', 'Disable AI and use fallback message')
//   .option('--no-branch', 'Commit directly to main without creating a new branch')
//   .option('--remote <url>', 'Add remote origin if repo is new')
//   .parse(process.argv);

// const [desc] = program.args;
// const opts = program.opts();

// /** Generate commit message */
// async function generateCommitMessage(diff) {
//   if (opts.noAi || !process.env.GEMINI_API_KEY) {
//     return `${opts.type}${opts.scope ? `(${opts.scope})` : ''}: ${desc}`;
//   }

//   const spinner = ora('ü§ñ Generating commit message with Gemini...').start();
//   try {
//     const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
//     const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
//     const prompt = `Generate a professional git commit message in Conventional Commit format based on this code diff:\n${diff}`;
//     const result = await model.generateContent(prompt);
//     spinner.succeed('‚úÖ Commit message generated by Gemini');
//     return result.response?.text()?.trim() || `${opts.type}: ${desc}`;
//   } catch (err) {
//     spinner.fail('‚ùå Gemini generation failed. Falling back to manual commit message.');
//     console.error(chalk.red(err.message));
//     return `${opts.type}${opts.scope ? `(${opts.scope})` : ''}: ${desc}`;
//   }
// }

// /** Stage all files */
// async function stageAllFiles() {
//   const spinner = ora('üìÇ Staging all files...').start();
//   try {
//     await git.add('./*');
//     spinner.succeed('‚úÖ All files staged');
//   } catch (err) {
//     spinner.fail('‚ùå Failed to stage files');
//     throw err;
//   }
// }

// /** Push branch with retry */
// async function pushBranch(branchName) {
//   const spinner = ora(`üöÄ Pushing branch "${branchName}"...`).start();
//   const maxRetries = 2;
//   let attempt = 0;
//   while (attempt <= maxRetries) {
//     try {
//       await git.push('origin', branchName);
//       spinner.succeed(`‚úÖ Successfully pushed branch "${branchName}"`);
//       return;
//     } catch (err) {
//       attempt++;
//       if (attempt > maxRetries) {
//         spinner.fail(`‚ùå Failed to push branch "${branchName}" after ${maxRetries + 1} attempts`);
//         throw err;
//       } else {
//         spinner.warn(`‚ö† Push failed. Retrying... (${attempt}/${maxRetries})`);
//       }
//     }
//   }
// }

// (async () => {
//   try {
//     // 1Ô∏è‚É£ Initialize repo if none exists
//     let isRepo = await git.checkIsRepo();
//     if (!isRepo) {
//       console.log(chalk.blue('‚Ñπ No git repository found. Initializing...'));
//       await git.init();
//       console.log(chalk.green('‚úÖ Git repository initialized'));
//       isRepo = true;
//     }

//     // 2Ô∏è‚É£ Add remote if provided
//     if (opts.remote) {
//       try {
//         await git.remote(['add', 'origin', opts.remote]);
//         console.log(chalk.green(`‚úÖ Remote origin set to ${opts.remote}`));
//       } catch {
//         console.log(chalk.yellow('‚ö† Remote origin may already exist.'));
//       }
//     }

//     // 3Ô∏è‚É£ Check if repo has commits
//     let hasCommits = true;
//     try {
//       await git.revparse(['--verify', 'HEAD']);
//     } catch {
//       hasCommits = false;
//     }

//     // 4Ô∏è‚É£ Determine branch
//     let branchName = 'main';
//     if (opts.noBranch || !hasCommits) {
//       // Commit directly to main
//       branchName = 'main';
//       await git.checkout(['-B', branchName]);
//       console.log(chalk.green(`‚úÖ Committing directly to branch: ${branchName}`));
//     } else {
//       // Existing repo, create feature branch
//       const branchInfo = await git.branch();
//       branchName = `${opts.type}/${desc.toLowerCase().replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}`;
//       if (branchInfo.all.includes(branchName)) {
//         await git.checkout(branchName);
//         console.log(chalk.blue(`‚Ñπ Switched to existing branch: ${branchName}`));
//       } else {
//         await git.checkoutLocalBranch(branchName);
//         console.log(chalk.blue(`‚Ñπ Created and switched to new branch: ${branchName}`));
//       }
//     }

//     // 5Ô∏è‚É£ Stage files
//     let diff = await git.diff(['--cached']);
//     if (!diff) {
//       console.log(chalk.yellow('‚ö† No staged changes found.'));
//       await stageAllFiles();
//       diff = await git.diff(['--cached']);
//       if (!diff) throw new Error('No changes detected to commit even after staging.');
//     }

//     // 6Ô∏è‚É£ Generate commit message
//     const commitMessage = await generateCommitMessage(diff);

//     // 7Ô∏è‚É£ Commit
//     await git.commit(commitMessage);
//     console.log(chalk.green(`‚úÖ Committed changes with message: "${commitMessage}"`));

//     // 8Ô∏è‚É£ Push
//     await pushBranch(branchName);

//   } catch (err) {
//     console.error(chalk.red(`‚ùå Error: ${err.message}`));
//     process.exit(1);
//   }
// })();
import { Command } from 'commander';
import simpleGit from 'simple-git';
import dotenv from 'dotenv';
import chalk from 'chalk';
import ora from 'ora';
import { GoogleGenerativeAI } from "@google/generative-ai";
import inquirer from 'inquirer';

dotenv.config();
const git = simpleGit();

// Warn if no Gemini key
if (!process.env.GEMINI_API_KEY) {
  console.warn(chalk.yellow('‚ö† GEMINI_API_KEY not found. AI commit messages will be disabled.'));
}

// CLI args
const program = new Command();
program
  .argument('<desc>', 'Short description of the change')
  .option('--type <type>', 'Commit type', 'feat')
  .option('--scope <scope>', 'Commit scope', '')
  .option('--no-ai', 'Disable AI and use fallback message')
  .option('--no-branch', 'Skip interactive branch choice and commit to main')
  .option('--remote <url>', 'Add remote origin if repo is new')
  .parse(process.argv);

const [desc] = program.args;
const opts = program.opts();

/** Generate commit message */
async function generateCommitMessage(diff) {
  if (opts.noAi || !process.env.GEMINI_API_KEY) {
    return `${opts.type}${opts.scope ? `(${opts.scope})` : ''}: ${desc}`;
  }

  const spinner = ora('ü§ñ Generating commit message with Gemini...').start();
  try {
    const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    const prompt = `Generate a professional git commit message in Conventional Commit format based on this code diff:\n${diff}`;
    const result = await model.generateContent(prompt);
    spinner.succeed('‚úÖ Commit message generated by Gemini');
    return result.response?.text()?.trim() || `${opts.type}: ${desc}`;
  } catch (err) {
    spinner.fail('‚ùå Gemini generation failed. Falling back to manual commit message.');
    console.error(chalk.red(err.message));
    return `${opts.type}${opts.scope ? `(${opts.scope})` : ''}: ${desc}`;
  }
}

/** Stage all files */
async function stageAllFiles() {
  const spinner = ora('üìÇ Staging all files...').start();
  try {
    await git.add('./*');
    spinner.succeed('‚úÖ All files staged');
  } catch (err) {
    spinner.fail('‚ùå Failed to stage files');
    throw err;
  }
}

/** Push branch with retry */
async function pushBranch(branchName) {
  const spinner = ora(`üöÄ Pushing branch "${branchName}"...`).start();
  const maxRetries = 2;
  let attempt = 0;
  while (attempt <= maxRetries) {
    try {
      await git.push('origin', branchName);
      spinner.succeed(`‚úÖ Successfully pushed branch "${branchName}"`);
      return;
    } catch (err) {
      attempt++;
      if (attempt > maxRetries) {
        spinner.fail(`‚ùå Failed to push branch "${branchName}" after ${maxRetries + 1} attempts`);
        throw err;
      } else {
        spinner.warn(`‚ö† Push failed. Retrying... (${attempt}/${maxRetries})`);
      }
    }
  }
}

(async () => {
  try {
    // 1Ô∏è‚É£ Initialize repo if none exists
    let isRepo = await git.checkIsRepo();
    if (!isRepo) {
      console.log(chalk.blue('‚Ñπ No git repository found. Initializing...'));
      await git.init();
      console.log(chalk.green('‚úÖ Git repository initialized'));
    }

    // 2Ô∏è‚É£ Add remote if provided
    if (opts.remote) {
      try {
        await git.remote(['add', 'origin', opts.remote]);
        console.log(chalk.green(`‚úÖ Remote origin set to ${opts.remote}`));
      } catch {
        console.log(chalk.yellow('‚ö† Remote origin may already exist.'));
      }
    }

    // 3Ô∏è‚É£ Check if repo has commits
    let hasCommits = true;
    try {
      await git.revparse(['--verify', 'HEAD']);
    } catch {
      hasCommits = false;
    }

    // 4Ô∏è‚É£ Determine branch interactively
    let branchName = 'main';
    const branchInfo = await git.branch();
    const currentBranch = branchInfo.current || 'main';

    if (opts.noBranch || !hasCommits) {
      // Commit directly to main
      branchName = 'main';
      await git.checkout(['-B', branchName]);
      console.log(chalk.green(`‚úÖ Committing directly to branch: ${branchName}`));
    } else {
      // Interactive choice
      const { branchChoice } = await inquirer.prompt([{
        type: 'list',
        name: 'branchChoice',
        message: `Current branch is "${currentBranch}". Where do you want to commit?`,
        choices: [
          { name: `Commit to current branch (${currentBranch})`, value: 'current' },
          { name: 'Create a new branch', value: 'new' },
        ]
      }]);

      if (branchChoice === 'new') {
        const { newBranchName } = await inquirer.prompt([{
          type: 'input',
          name: 'newBranchName',
          message: 'Enter new branch name (leave empty to auto-generate):',
        }]);
        branchName = newBranchName || `${opts.type}/${desc.toLowerCase().replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}`;
        await git.checkoutLocalBranch(branchName);
        console.log(chalk.blue(`‚Ñπ Created and switched to new branch: ${branchName}`));
      } else {
        branchName = currentBranch;
        await git.checkout(branchName);
        console.log(chalk.blue(`‚Ñπ Committing to current branch: ${branchName}`));
      }
    }

    // 5Ô∏è‚É£ Stage files
    let diff = await git.diff(['--cached']);
    if (!diff) {
      console.log(chalk.yellow('‚ö† No staged changes found.'));
      await stageAllFiles();
      diff = await git.diff(['--cached']);
      if (!diff) throw new Error('No changes detected to commit even after staging.');
    }

    // 6Ô∏è‚É£ Generate commit message
    const commitMessage = await generateCommitMessage(diff);

    // 7Ô∏è‚É£ Commit
    await git.commit(commitMessage);
    console.log(chalk.green(`‚úÖ Committed changes with message: "${commitMessage}"`));

    // 8Ô∏è‚É£ Ask before push
    const { confirmPush } = await inquirer.prompt([{
      type: 'confirm',
      name: 'confirmPush',
      message: `Do you want to push branch "${branchName}" to remote?`,
      default: true
    }]);

    if (confirmPush) {
      await pushBranch(branchName);
    } else {
      console.log(chalk.yellow('‚ö† Push skipped.'));
    }

  } catch (err) {
    console.error(chalk.red(`‚ùå Error: ${err.message}`));
    process.exit(1);
  }
})();
